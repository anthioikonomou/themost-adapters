{"version":3,"sources":["../src/index.js"],"names":["createInstance","async","_","util","sqlite","TraceUtils","QueryExpression","QueryField","SqlUtils","SqlFormatter","sqlite3","verbose","SqliteAdapter","options","database","rawConnection","callback","self","Database","err","close","log","query","values","format","fn","open","transaction","call","run","undefined","name","view","create","obj","isNil","migration","result","test","replace","formatType","waterfall","cb","supportMigrations","table","exists","arg","execute","appliesTo","version","updated","columns","args","strFields","add","filter","x","map","join","sql","expressions","forceAlter","column","newType","oldType","Array","isArray","remove","i","colIndex","findIndex","y","primary","splice","length","change","find","type","toUpperCase","concat","nullable","push","Error","forEach","eachSeries","expr","indexes","tableIndexes","index","indexCallback","model","description","entity","attribute","size","migrate","q","from","select","max","value","parseInt","id","batch","count","has_sequence","arr","iterator","col","ordinal","cid","notnull","pk","matches","exec","scale","drop","thisArg","executeInTransaction","tr","formatter","SqliteFormatter","e","process","env","NODE_ENV","JSON","stringify","prepared","prepare","all","keys","Object","lastval","insertId","list","this1","hasOwnProperty","origin","cols","apply","ix","sqlCreateIndex","escapeName","nCols","indexOf","field","s","zeroPad","number","res","toString","settings","nameFormat","NAME_FORMAT","forceAlias","unquoted","Date","escapeDate","bind","REGEXP_SINGLE_QUOTE","SINGLE_QUOTE_ESCAPE","REGEXP_DOUBLE_QUOTE","DOUBLE_QUOTE_ESCAPE","REGEXP_SLASH","SLASH_ESCAPE","val","year","getFullYear","month","getMonth","day","getDate","hour","getHours","minute","getMinutes","second","getSeconds","millisecond","getMilliseconds","offset","getTimezoneOffset","timezone","Math","floor","p0","p1","escape","s1","pos","valueOf"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * MOST Web Framework 2.0 Codename Blueshift\n * Copyright (c) 2014, Kyriakos Barbounakis k.barbounakis@gmail.com\n *                     Anthi Oikonomou anthioikonomou@gmail.com\n *\n * Use of this source code is governed by an BSD-3-Clause license that can be\n * found in the LICENSE file at https://themost.io/license\n */\nimport async from 'async';\nimport _ from 'lodash';\nimport util from 'util';\nimport sqlite from 'sqlite3';\nimport {TraceUtils} from '@themost/common';\nimport {QueryExpression, QueryField, SqlUtils, SqlFormatter} from '@themost/query';\nconst sqlite3 = sqlite.verbose();\n\n/**\n * @class\n * @augments DataAdapter\n * @param {*} options\n * @constructor\n */\nexport class SqliteAdapter {\n    \n    constructor(options) {\n        /**\n         * @type {{database: string}}\n         */\n        this.options = options || { database: ':memory:' };\n        /**\n         * Represents the database raw connection associated with this adapter\n         * @type {*}\n         */\n        this.rawConnection = null;\n    }\n\n    open(callback) {\n        const self = this;\n        callback = callback || function() {};\n        if (self.rawConnection) {\n            callback();\n        }\n        else {\n            //try to open or create database\n            self.rawConnection = new sqlite3.Database(self.options.database,6, function(err) {\n                if (err) {\n                    self.rawConnection = null;\n                }\n                callback(err);\n\n            });\n        }\n    }\n\n    close(callback) {\n        const self = this;\n        callback = callback || function() {};\n        try {\n            if (self.rawConnection)\n            {\n                //close connection\n                self.rawConnection.close(function() {\n                    //and finally return\n                    callback();\n                });\n            }\n            else {\n                callback();\n            }\n\n        }\n        catch (err) {\n            TraceUtils.log('An error occured while closing database.');\n            TraceUtils.log(err);\n            //call callback without error\n            callback();\n        }\n    }\n\n    /**\n     * @param {string} query\n     * @param {*=} values\n     */\n    prepare(query, values) {\n        return SqlUtils.format(query,values);\n    }\n\n    static formatType(field) {\n        const size = parseInt(field.size);\n        let s;\n        switch (field.type)\n        {\n            case 'Boolean':\n                s = 'INTEGER(1,0)';\n                break;\n            case 'Byte':\n                s = 'INTEGER(1,0)';\n                break;\n            case 'Number':\n            case 'Float':\n                s = 'REAL';\n                break;\n            case 'Counter':\n                return 'INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL';\n            case 'Currency':\n                s =  'NUMERIC(' + (field.size || 19) + ',4)';\n                break;\n            case 'Decimal':\n                s =  'NUMERIC';\n                if ((field.size) && (field.scale)) { s += '(' + field.size + ',' + field.scale + ')'; }\n                break;\n            case 'Date':\n            case 'DateTime':\n                s = 'NUMERIC';\n                break;\n            case 'Time':\n                s = size>0 ?  util.format('TEXT(%s,0)', size) : 'TEXT';\n                break;\n            case 'Long':\n                s = 'NUMERIC';\n                break;\n            case 'Duration':\n                s = size>0 ?  util.format('TEXT(%s,0)', size) : 'TEXT(48,0)';\n                break;\n            case 'Integer':\n                s = 'INTEGER' + (field.size ? '(' + field.size + ',0)':'' );\n                break;\n            case 'URL':\n            case 'Text':\n            case 'Note':\n                s =field.size ? util.format('TEXT(%s,0)', field.size) : 'TEXT';\n                break;\n            case 'Image':\n            case 'Binary':\n                s ='BLOB';\n                break;\n            case 'Guid':\n                s = 'TEXT(36,0)';\n                break;\n            case 'Short':\n                s = 'INTEGER(2,0)';\n                break;\n            default:\n                s = 'INTEGER';\n                break;\n        }\n        if (field.primary) {\n            return s.concat(' PRIMARY KEY NOT NULL');\n        }\n        else {\n            return s.concat((field.nullable===undefined) ? ' NULL': (field.nullable ? ' NULL': ' NOT NULL'));\n        }\n    }\n\n    /**\n     * Begins a transactional operation by executing the given function\n     * @param fn {function} The function to execute\n     * @param callback {function(Error=)} The callback that contains the error -if any- and the results of the given operation\n     */\n    executeInTransaction(fn, callback) {\n        const self = this;\n        //ensure parameters\n        fn = fn || function() {}; callback = callback || function() {};\n        self.open(function(err) {\n            if (err) {\n                callback(err);\n            }\n            else {\n                if (self.transaction) {\n                    fn.call(self, function(err) {\n                        callback(err);\n                    });\n                }\n                else {\n                    //begin transaction\n                    self.rawConnection.run('BEGIN TRANSACTION;', undefined, function(err) {\n                        if (err) {\n                            callback(err);\n                            return;\n                        }\n                        //initialize dummy transaction object (for future use)\n                        self.transaction = { };\n                        //execute function\n                        fn.call(self, function(err) {\n                            if (err) {\n                                //rollback transaction\n                                self.rawConnection.run('ROLLBACK;', undefined, function() {\n                                    self.transaction = null;\n                                    callback(err);\n                                });\n                            }\n                            else {\n                                //commit transaction\n                                self.rawConnection.run('COMMIT;', undefined, function(err) {\n                                    self.transaction = null;\n                                    callback(err);\n                                });\n                            }\n                        });\n                    });\n                }\n            }\n        });\n    }\n\n    /**\n     *\n     * @param {string} name\n     * @param {QueryExpression|*} query\n     * @param {function(Error=)} callback\n     */\n    createView(name, query, callback) {\n        this.view(name).create(query, callback);\n    }\n\n    /*\n     * @param {DataModelMigration|*} obj An Object that represents the data model scheme we want to migrate\n     * @param {function(Error=)} callback\n     */\n    migrate(obj, callback) {\n        const self = this;\n        callback = callback || function() {};\n        if (_.isNil(obj)) { return callback(); }\n        /**\n         * @type {DataModelMigration|*}\n         */\n        const migration = obj;\n\n        const format = function(format, obj)\n        {\n            let result = format;\n            if (/%t/.test(format))\n                result = result.replace(/%t/g,SqliteAdapter.formatType(obj));\n            if (/%f/.test(format))\n                result = result.replace(/%f/g,obj.name);\n            return result;\n        };\n\n\n        async.waterfall([\n            //1. Check migrations table existence\n            function(cb) {\n                if (SqliteAdapter.supportMigrations) {\n                    cb(null, true);\n                    return;\n                }\n                self.table('migrations').exists(function(err, exists) {\n                    if (err) { cb(err); return; }\n                    cb(null, exists);\n                });\n            },\n            //2. Create migrations table, if it does not exist\n            function(arg, cb) {\n                if (arg) { cb(null, 0); return; }\n                //create migrations table\n                self.execute('CREATE TABLE migrations(\"id\" INTEGER PRIMARY KEY AUTOINCREMENT, ' +\n                    '\"appliesTo\" TEXT NOT NULL, \"model\" TEXT NULL, \"description\" TEXT,\"version\" TEXT NOT NULL)',\n                    [], function(err) {\n                        if (err) { cb(err); return; }\n                        SqliteAdapter.supportMigrations=true;\n                        cb(null, 0);\n                    });\n            },\n            //3. Check if migration has already been applied (true=Table version is equal to migration version, false=Table version is older from migration version)\n            function(arg, cb) {\n                self.table(migration.appliesTo).version(function(err, version) {\n                    if (err) { cb(err); return; }\n                    cb(null, (version>=migration.version));\n                });\n            },\n            //4a. Check table existence (-1=Migration has already been applied, 0=Table does not exist, 1=Table exists)\n            function(arg, cb) {\n                //migration has already been applied (set migration.updated=true)\n                if (arg) {\n                    migration.updated=true;\n                    cb(null, -1);\n                }\n                else {\n                    self.table(migration.appliesTo).exists(function(err, exists) {\n                        if (err) { cb(err); return; }\n                        cb(null, exists ? 1 : 0);\n                    });\n\n                }\n            },\n            //4. Get table columns\n            function(arg, cb) {\n                //migration has already been applied\n                if (arg<0) { cb(null, [arg, null]); return; }\n                self.table(migration.appliesTo).columns(function(err, columns) {\n                    if (err) { cb(err); return; }\n                    cb(null, [arg, columns]);\n                });\n            },\n            //5. Migrate target table (create or alter)\n            function(args, cb) {\n                //migration has already been applied (args[0]=-1)\n                if (args[0] < 0) {\n                    cb(null, args[0]);\n                }\n                else if (args[0] === 0) {\n                    //create table\n                    const strFields = migration.add.filter(function(x) {\n                        return !x['oneToMany'];\n                    }).map(\n                        function(x) {\n                            return format('\"%f\" %t', x);\n                        }).join(', ');\n                    const sql = util.format('CREATE TABLE \"%s\" (%s)', migration.appliesTo, strFields);\n                    self.execute(sql, null, function(err) {\n                        if (err) { cb(err); return; }\n                        cb(null, 1);\n                    });\n                }\n                else if (args[0] === 1) {\n                    const expressions = [];\n\n                    const /**\n                     * @type {{columnName:string,ordinal:number,dataType:*, maxLength:number,isNullable:number,,primary:boolean }[]}\n                     */\n                    columns = args[1];\n\n                    let forceAlter = false;\n                    let column;\n                    let newType;\n                    let oldType;\n                    //validate operations\n\n                    //1. columns to be removed\n                    if (Array.isArray(migration.remove)) {\n                        if (migration.remove>0) {\n                            for (let i = 0; i < migration.remove.length; i++) {\n                                let x = migration.remove[i];\n                                let colIndex = _.findIndex(columns, (y) => {\n                                    return y.name === x.name;\n                                });\n                                if (colIndex>=0) {\n                                    if (!columns[colIndex].primary) {\n                                        forceAlter = true;\n                                    }\n                                    else {\n                                        migration.remove.splice(i, 1);\n                                        i-=1;\n                                    }\n                                }\n                                else {\n                                    migration.remove.splice(i, 1);\n                                    i-=1;\n                                }\n                            }\n                        }\n                    }\n                    //1. columns to be changed\n                    if (Array.isArray(migration.change)) {\n                        if (migration.change>0) {\n\n                            for (let i = 0; i < migration.change.length; i++) {\n                                let x = migration.change[i];\n                                column = _.find(columns, (y) => {\n                                    return y.name === x.name;\n                                });\n                                if (column) {\n                                    if (!column.primary) {\n                                        //validate new column type (e.g. TEXT(120,0) NOT NULL)\n                                        newType = format('%t', x); oldType = column.type.toUpperCase().concat(column.nullable ? ' NOT NULL' : ' NULL');\n                                        if ((newType !== oldType)) {\n                                            //force alter\n                                            forceAlter = true;\n                                        }\n                                    }\n                                    else {\n                                        //remove column from change collection (because it's a primary key)\n                                        migration.change.splice(i, 1);\n                                        i-=1;\n                                    }\n                                }\n                                else {\n                                    //add column (column was not found in table)\n                                    migration.add.push(x);\n                                    //remove column from change collection\n                                    migration.change.splice(i, 1);\n                                    i-=1;\n                                }\n\n                            }\n\n                        }\n                    }\n                    if (Array.isArray(migration.add)) {\n\n                        for (let i = 0; i < migration.add.length; i++) {\n                            let x = migration.add[i];\n                            column = _.find(columns, (y) => {\n                                return (y.name === x.name);\n                            });\n                            if (column) {\n                                if (column.primary) {\n                                    migration.add.splice(i, 1);\n                                    i-=1;\n                                }\n                                else {\n                                    newType = format('%t', x); oldType = column.type.toUpperCase().concat(column.nullable ? ' NOT NULL' : ' NULL');\n                                    if (newType === oldType) {\n                                        //remove column from add collection\n                                        migration.add.splice(i, 1);\n                                        i-=1;\n                                    }\n                                    else {\n                                        forceAlter = true;\n                                    }\n                                }\n                            }\n                        }\n                        if (forceAlter) {\n                            cb(new Error('Full table migration is not yet implemented.'));\n                            return;\n                        }\n                        else {\n                            migration.add.forEach(function(x) {\n                                //search for columns\n                                expressions.push(util.format('ALTER TABLE \"%s\" ADD COLUMN \"%s\" %s', migration.appliesTo, x.name, SqliteAdapter.formatType(x)));\n                            });\n                        }\n\n                    }\n                    if (expressions.length>0) {\n                        async.eachSeries(expressions, function(expr,cb) {\n                            self.execute(expr, [], function(err) {\n                                cb(err);\n                            });\n                        }, function(err) {\n                            if (err) { cb(err); return; }\n                            cb(null, 1);\n                        });\n                    }\n                    else {\n                        cb(null, 2);\n                    }\n                }\n                else {\n                    cb(new Error('Invalid table status.'));\n                }\n            },\n            //Apply data model indexes\n            function (arg, cb) {\n                if (arg<=0) { return cb(null, arg); }\n                if (migration.indexes) {\n                    const tableIndexes = self.indexes(migration.appliesTo);\n                    //enumerate migration constraints\n                    async.eachSeries(migration.indexes, function(index, indexCallback) {\n                        tableIndexes.create(index.name, index.columns, indexCallback);\n                    }, function(err) {\n                        //throw error\n                        if (err) { return cb(err); }\n                        //or return success flag\n                        return cb(null, 1);\n                    });\n                }\n                else {\n                    //do nothing and exit\n                    return cb(null, 1);\n                }\n            },\n            function(arg, cb) {\n                if (arg>0) {\n                    //log migration to database\n                    self.execute('INSERT INTO migrations(\"appliesTo\", \"model\", \"version\", \"description\") VALUES (?,?,?,?)', [migration.appliesTo,\n                        migration.model,\n                        migration.version,\n                        migration.description ], function(err) {\n                        if (err)  {\n                            return cb(err);\n                        }\n                        cb(null, 1);\n                    });\n                }\n                else {\n                    migration.updated = true;\n                    cb(null, arg);\n                }\n            }\n        ], function(err) {\n            callback(err);\n        });\n\n    }\n\n    /**\n     * Produces a new identity value for the given entity and attribute.\n     * @param entity {String} The target entity name\n     * @param attribute {String} The target attribute\n     * @param callback {Function=}\n     */\n    selectIdentity(entity, attribute, callback) {\n\n        const self = this;\n\n        const migration = {\n            appliesTo:'increment_id',\n            model:'increments',\n            description:'Increments migration (version 1.0)',\n            version:'1.0',\n            add:[\n                { name:'id', type:'Counter', primary:true },\n                { name:'entity', type:'Text', size:120 },\n                { name:'attribute', type:'Text', size:120 },\n                { name:'value', type:'Integer' }\n            ]\n        };\n        //ensure increments entity\n        self.migrate(migration, function(err)\n        {\n            //throw error if any\n            if (err) { callback.call(self,err); return; }\n            self.execute('SELECT * FROM increment_id WHERE entity=? AND attribute=?', [entity, attribute], function(err, result) {\n                if (err) { callback.call(self,err); return; }\n                if (result.length===0) {\n                    //get max value by querying the given entity\n                    const q = new QueryExpression().from(entity).select([new QueryField().max(attribute)]);\n                    self.execute(q,null, function(err, result) {\n                        if (err) { callback.call(self, err); return; }\n                        let value = 1;\n                        if (result.length>0) {\n                            value = (parseInt(result[0][attribute]) || 0)+ 1;\n                        }\n                        self.execute('INSERT INTO increment_id(entity, attribute, value) VALUES (?,?,?)',[entity, attribute, value], function(err) {\n                            //throw error if any\n                            if (err) { callback.call(self, err); return; }\n                            //return new increment value\n                            callback.call(self, err, value);\n                        });\n                    });\n                }\n                else {\n                    //get new increment value\n                    const value = parseInt(result[0].value) + 1;\n                    self.execute('UPDATE increment_id SET value=? WHERE id=?',[value, result[0].id], function(err) {\n                        //throw error if any\n                        if (err) { callback.call(self, err); return; }\n                        //return new increment value\n                        callback.call(self, err, value);\n                    });\n                }\n            });\n        });\n    }\n\n    /**\n     * Executes an operation against database and returns the results.\n     * @param {*} batch\n     * @param {function(Error=)} callback\n     */\n    executeBatch(batch, callback) {\n        callback = callback || function() {};\n        callback(new Error('DataAdapter.executeBatch() is obsolete. Use DataAdapter.executeInTransaction() instead.'));\n    }\n\n    table(name) {\n        const self = this;\n        return {\n            /**\n             * @param {function(Error,Boolean=)} callback\n             */\n            exists:function(callback) {\n                self.execute('SELECT COUNT(*) count FROM sqlite_master WHERE name=? AND type=\\'table\\';', [name], function(err, result) {\n                    if (err) { callback(err); return; }\n                    callback(null, (result[0].count>0));\n                });\n            },\n            /**\n             * @param {function(Error,string=)} callback\n             */\n            version:function(callback) {\n                self.execute('SELECT MAX(version) AS version FROM migrations WHERE appliesTo=?',\n                    [name], function(err, result) {\n                        if (err) { return callback(err); }\n                        if (result.length === 0)\n                            callback(null, '0.0');\n                        else\n                            callback(null, result[0].version || '0.0');\n                    });\n            },\n            /**\n             * @param {function(Error,Boolean=)} callback\n             */\n            has_sequence:function(callback) {\n                callback = callback || function() {};\n                self.execute('SELECT COUNT(*) count FROM sqlite_sequence WHERE name=?',\n                    [name], function(err, result) {\n                        if (err) { callback(err); return; }\n                        callback(null, (result[0].count>0));\n                    });\n            },\n            /**\n             * @param {function(Error=,Array=)} callback\n             */\n            columns:function(callback) {\n                callback = callback || function() {};\n                self.execute('PRAGMA table_info(?)',\n                    [name], function(err, result) {\n                        if (err) { callback(err); return; }\n                        const arr = [];\n                        /**\n                         * enumerates table columns\n                         * @param {{name:string},{cid:number},{type:string},{notnull:number},{pk:number}} x\n                         */\n                        const iterator = function(x) {\n                            const col = { name: x.name, ordinal: x.cid, type: x.type,nullable: (x.notnull ? true : false), primary: (x.pk === 1) };\n                            const matches = /(\\w+)\\((\\d+),(\\d+)\\)/.exec(x.type);\n                            if (matches) {\n                                //extract max length attribute (e.g. integer(2,0) etc)\n                                if (parseInt(matches[2])>0) { col.size =  parseInt(matches[2]); }\n                                //extract scale attribute from field (e.g. integer(2,0) etc)\n                                if (parseInt(matches[3])>0) { col.scale =  parseInt(matches[3]); }\n                            }\n                            arr.push(col);\n                        };\n                        result.forEach(iterator);\n                        callback(null, arr);\n                    });\n            }\n        };\n\n    }\n\n    view(name) {\n        const self = this;\n        return {\n            /**\n             * @param {function(Error,Boolean=)} callback\n             */\n            exists:function(callback) {\n                self.execute('SELECT COUNT(*) count FROM sqlite_master WHERE name=? AND type=\\'view\\';', [name], function(err, result) {\n                    if (err) { callback(err); return; }\n                    callback(null, (result[0].count>0));\n                });\n            },\n            /**\n             * @param {function(Error=)} callback\n             */\n            drop:function(callback) {\n                callback = callback || function() {};\n                self.open(function(err) {\n                   if (err) { callback(err); return; }\n                    const sql = util.format('DROP VIEW IF EXISTS `%s`',name);\n                    self.execute(sql, undefined, function(err) {\n                        if (err) { callback(err); return; }\n                        callback();\n                    });\n                });\n            },\n            /**\n             * @param {QueryExpression|*} q\n             * @param {function(Error=)} callback\n             */\n            create:function(q, callback) {\n                const thisArg = this;\n                self.executeInTransaction(function(tr) {\n                    thisArg.drop(function(err) {\n                        if (err) { tr(err); return; }\n                        try {\n                            let sql = util.format('CREATE VIEW `%s` AS ',name);\n                            const formatter = new SqliteFormatter();\n                            sql += formatter.format(q);\n                            self.execute(sql, undefined, tr);\n                        }\n                        catch(e) {\n                            tr(e);\n                        }\n                    });\n                }, function(err) {\n                    callback(err);\n                });\n\n            }\n        };\n    }\n\n    /**\n     * Executes a query against the underlying database\n     * @param query {QueryExpression|string|*}\n     * @param values {*=}\n     * @param {function(Error=,*=)} callback\n     */\n    execute(query, values, callback) {\n        const self = this;\n        let sql = null;\n        try {\n\n            if (typeof query === 'string') {\n                //get raw sql statement\n                sql = query;\n            }\n            else {\n                //format query expression or any object that may be act as query expression\n                const formatter = new SqliteFormatter();\n                sql = formatter.format(query);\n            }\n            //validate sql statement\n            if (typeof sql !== 'string') {\n                callback.call(self, new Error('The executing command is of the wrong type or empty.'));\n                return;\n            }\n            //ensure connection\n            self.open(function(err) {\n                if (err) {\n                    callback.call(self, err);\n                }\n                else {\n                    //log statement (optional)\n                    if (process.env.NODE_ENV==='development')\n                        TraceUtils.log(util.format('SQL:%s, Parameters:%s', sql, JSON.stringify(values)));\n\n                    //prepare statement - the traditional way\n                    const prepared = self.prepare(sql, values);\n\n                    let fn;\n                    //validate statement\n                    if (/^(SELECT|PRAGMA)/ig.test(prepared)) {\n                        //prepare for select\n                        fn = self.rawConnection.all;\n                    }\n                    else {\n                        //otherwise prepare for run\n                        fn = self.rawConnection.run;\n                    }\n                    //execute raw command\n                    fn.call(self.rawConnection, prepared, [] , function(err, result) {\n                        if (err) {\n                            //log sql\n                            TraceUtils.log(util.format('SQL Error:%s', prepared));\n                            callback(err);\n                        }\n                        else {\n                            if (result) {\n                                if (typeof result === 'object') {\n                                    let keys;\n                                    if (Array.isArray(result)) {\n                                        if (result.length>0) {\n                                            keys = Object.keys(result[0]);\n                                            result.forEach(function(x) {\n                                                keys.forEach(function(y) {\n                                                    if (x[y] === null) { delete x[y]; }\n                                                });\n                                            });\n                                        }\n                                    }\n                                    else {\n                                        keys = Object.keys(result);\n                                        keys.forEach(function(y) {\n                                            if (result[y] === null) { delete result[y]; }\n                                        });\n                                    }\n                                }\n                                return callback(null, result);\n                            }\n                            else {\n                                return callback();\n                            }\n\n                        }\n                    });\n                }\n            });\n        }\n        catch (e) {\n            callback.call(self, e);\n        }\n    }\n\n    lastIdentity(callback) {\n        const self = this;\n        self.open(function(err) {\n            if (err) {\n                callback(err);\n            }\n            else {\n                //execute lastval (for sequence)\n                self.execute('SELECT last_insert_rowid() as lastval', [], function(err, lastval) {\n                    if (err) {\n                        callback(null, { insertId: null });\n                    }\n                    else {\n                        lastval = lastval || [];\n                        if (lastval.length>0)\n                            callback(null, { insertId:lastval[0].lastval });\n                        else\n                            callback(null, { insertId: null });\n                    }\n                });\n            }\n        });\n    }\n\n    indexes(table) {\n        const self = this, formatter = new SqliteFormatter();\n        return {\n            list: function (callback) {\n                const this1 = this;\n                if (this1.hasOwnProperty('indexes_')) {\n                    return callback(null, this1['indexes_']);\n                }\n                self.execute(util.format('PRAGMA INDEX_LIST(`%s`)', table), null , function (err, result) {\n                    if (err) { return callback(err); }\n                    const indexes = result.filter(function(x) {\n                        return x.origin === 'c';\n                    }).map(function(x) {\n                        return {\n                            name:x.name,\n                            columns:[]\n                        };\n                    });\n                    async.eachSeries(indexes, function(index, cb) {\n                        self.execute(util.format('PRAGMA INDEX_INFO(`%s`)', index.name), null, function(err, columns) {\n                           if (err) { return cb(err); }\n                            index.columns = _.map(columns, function(x) {\n                                return x.name;\n                            });\n                           return cb();\n                        });\n                    }, function(err) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        this1['indexes_'] = indexes;\n                        return callback(null, indexes);\n                    });\n                });\n            },\n            /**\n             * @param {string} name\n             * @param {Array|string} columns\n             * @param {Function} callback\n             */\n            create: function(name, columns, callback) {\n                const cols = [];\n                if (typeof columns === 'string') {\n                    cols.push(columns);\n                }\n                else if (Array.isArray(columns)) {\n                    cols.push.apply(cols, columns);\n                }\n                else {\n                    return callback(new Error('Invalid parameter. Columns parameter must be a string or an array of strings.'));\n                }\n\n                const thisArg = this;\n                thisArg.list(function(err, indexes) {\n                    if (err) { return callback(err); }\n                    const ix = indexes.find(function(x) { return x.name === name; });\n                    //format create index SQL statement\n                    const sqlCreateIndex = util.format('CREATE INDEX %s ON %s(%s)',\n                        formatter.escapeName(name),\n                        formatter.escapeName(table),\n                        cols.map(function(x) {\n                            return formatter.escapeName(x);\n                        }).join(','));\n                    if (typeof ix === 'undefined' || ix === null) {\n                        self.execute(sqlCreateIndex, [], callback);\n                    }\n                    else {\n                        let nCols = cols.length;\n                        //enumerate existing columns\n                        ix.columns.forEach(function(x) {\n                            if (cols.indexOf(x)>=0) {\n                                //column exists in index\n                                nCols -= 1;\n                            }\n                        });\n                        if (nCols>0) {\n                            //drop index\n                            thisArg.drop(name, function(err) {\n                                if (err) { return callback(err); }\n                                //and create it\n                                self.execute(sqlCreateIndex, [], callback);\n                            });\n                        }\n                        else {\n                            //do nothing\n                            return callback();\n                        }\n                    }\n                });\n\n\n            },\n            drop: function(name, callback) {\n                if (typeof name !== 'string') {\n                    return callback(new Error('Name must be a valid string.'));\n                }\n                self.execute(util.format('PRAGMA INDEX_LIST(`%s`)', table), null, function(err, result) {\n                    if (err) { return callback(err); }\n                    const exists = typeof result.find(function(x) { return x.name===name; }) !== 'undefined';\n                    if (!exists) {\n                        return callback();\n                    }\n                    self.execute(util.format('DROP INDEX %s', self.escapeName(name)), [], callback);\n                });\n            }\n        };\n    }\n}\n\nfunction zeroPad(number, length) {\n    number = number || 0;\n    let res = number.toString();\n    while (res.length < length) {\n        res = '0' + res;\n    }\n    return res;\n}\n\n/**\n * @augments {SqlFormatter}\n */\nexport class SqliteFormatter extends SqlFormatter {\n    /**\n     * @constructor\n     */\n    constructor() {\n        super();\n        this.settings = {\n            nameFormat:SqliteFormatter.NAME_FORMAT,\n            forceAlias:true\n        };\n    }\n\n    escapeName(name) {\n        if (typeof name === 'string')\n            return name.replace(/(\\w+)/ig, this.settings.nameFormat);\n        return name;\n    }\n\n    /**\n     * Escapes an object or a value and returns the equivalent sql value.\n     * @param {*} value - A value that is going to be escaped for SQL statements\n     * @param {boolean=} unquoted - An optional value that indicates whether the resulted string will be quoted or not.\n     * returns {string} - The equivalent SQL string value\n     */\n    escape(value, unquoted) {\n        if (typeof value === 'boolean') { return value ? '1' : '0'; }\n        if (value instanceof Date) {\n            return this.escapeDate(value);\n        }\n        let res = super.escape.bind(this)(value, unquoted);\n        if (typeof value === 'string') {\n            if (REGEXP_SINGLE_QUOTE.test(res))\n            //escape single quote (that is already escaped)\n                res = res.replace(/\\\\'/g, SINGLE_QUOTE_ESCAPE);\n            if (REGEXP_DOUBLE_QUOTE.test(res))\n            //escape double quote (that is already escaped)\n                res = res.replace(/\\\\\"/g, DOUBLE_QUOTE_ESCAPE);\n            if (REGEXP_SLASH.test(res))\n            //escape slash (that is already escaped)\n                res = res.replace(/\\\\\\\\/g, SLASH_ESCAPE);\n        }\n        return res;\n    }\n\n    /**\n     * @param {Date|*} val\n     * @returns {string}\n     */\n    escapeDate(val) {\n        const year   = val.getFullYear();\n        const month  = zeroPad(val.getMonth() + 1, 2);\n        const day    = zeroPad(val.getDate(), 2);\n        const hour   = zeroPad(val.getHours(), 2);\n        const minute = zeroPad(val.getMinutes(), 2);\n        const second = zeroPad(val.getSeconds(), 2);\n        const millisecond = zeroPad(val.getMilliseconds(), 3);\n        //format timezone\n        const offset = val.getTimezoneOffset(), timezone = (offset<=0 ? '+' : '-') + zeroPad(-Math.floor(offset/60),2) + ':' + zeroPad(offset%60,2);\n        return '\\'' + year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second + '.' + millisecond + timezone + '\\'';\n    }\n\n    /**\n     * Implements indexOf(str,substr) expression formatter.\n     * @param {string} p0 The source string\n     * @param {string} p1 The string to search for\n     * @returns {string}\n     */\n    $indexof(p0, p1) {\n        return util.format('(INSTR(%s,%s)-1)', this.escape(p0), this.escape(p1));\n    }\n\n    /**\n     * Implements indexOf(str,substr) expression formatter.\n     * @param {string} p0 The source string\n     * @param {string} p1 The string to search for\n     * @returns {string}\n     */\n    $indexOf(p0, p1) {\n        return util.format('(INSTR(%s,%s)-1)', this.escape(p0), this.escape(p1));\n    }\n\n    /**\n     * Implements contains(a,b) expression formatter.\n     * @param {*} p0 The source string\n     * @param {*} p1 The string to search for\n     * @returns {string}\n     */\n    $text(p0, p1) {\n        return util.format('(INSTR(%s,%s)-1)>=0', this.escape(p0), this.escape(p1));\n    }\n\n    /**\n     * Implements simple regular expression formatter. Important Note: SQLite 3 does not provide a core sql function for regular expression matching.\n     * @param {*} p0 The source string or field\n     * @param {*} p1 The string to search for\n     */\n    $regex(p0, p1) {\n        //escape expression\n        let s1 = this.escape(p1, true);\n        //implement starts with equivalent for LIKE T-SQL\n        if (/^\\^/.test(s1)) {\n            s1 = s1.replace(/^\\^/,'');\n        }\n        else {\n            s1 = '%' + s1;\n        }\n        //implement ends with equivalent for LIKE T-SQL\n        if (/\\$$/.test(s1)) {\n            s1 = s1.replace(/\\$$/,'');\n        }\n        else {\n            s1 += '%';\n        }\n        return util.format('LIKE(\\'%s\\',%s) >= 1',s1, this.escape(p0));\n    }\n\n    /**\n     * Implements concat(a,b) expression formatter.\n     * @param {*} p0\n     * @param {*} p1\n     * @returns {string}\n     */\n    $concat(p0, p1) {\n        return util.format('(IFNULL(%s,\\'\\') || IFNULL(%s,\\'\\'))', this.escape(p0),  this.escape(p1));\n    }\n\n    /**\n     * Implements substring(str,pos) expression formatter.\n     * @param {String} p0 The source string\n     * @param {Number} pos The starting position\n     * @param {Number=} length The length of the resulted string\n     * @returns {string}\n     */\n    $substring(p0, pos, length) {\n        if (length)\n            return util.format('SUBSTR(%s,%s,%s)', this.escape(p0), pos.valueOf()+1, length.valueOf());\n        else\n            return util.format('SUBSTR(%s,%s)', this.escape(p0), pos.valueOf()+1);\n    }\n\n    /**\n     * Implements substring(str,pos) expression formatter.\n     * @param {String} p0 The source string\n     * @param {Number} pos The starting position\n     * @param {Number=} length The length of the resulted string\n     * @returns {string}\n     */\n    $substr(p0, pos, length) {\n        if (length)\n            return util.format('SUBSTR(%s,%s,%s)', this.escape(p0), pos.valueOf()+1, length.valueOf());\n        else\n            return util.format('SUBSTR(%s,%s)', this.escape(p0), pos.valueOf()+1);\n    }\n\n    /**\n     * Implements length(a) expression formatter.\n     * @param {*} p0\n     * @returns {string}\n     */\n    $length(p0) {\n        return util.format('LENGTH(%s)', this.escape(p0));\n    }\n\n    $ceiling(p0) {\n        return util.format('CEIL(%s)', this.escape(p0));\n    }\n\n    $startswith(p0, p1) {\n        //validate params\n        if (_.isNil(p0) || _.isNil(p1))\n            return '';\n        return 'LIKE(\\'' + this.escape(p1, true) + '%\\',' + this.escape(p0) + ')';\n    }\n\n    $contains(p0, p1) {\n        //validate params\n        if (_.isNil(p0) || _.isNil(p1))\n            return '';\n        return 'LIKE(\\'%' + this.escape(p1, true) + '%\\',' + this.escape(p0) + ')';\n    }\n\n    $endswith(p0, p1) {\n        //validate params\n        if (_.isNil(p0) || _.isNil(p1))\n            return '';\n        return 'LIKE(\\'%' + this.escape(p1, true) + '\\',' + this.escape(p0) + ')';\n    }\n\n    $day(p0) { return 'CAST(strftime(\\'%d\\', ' + this.escape(p0) + ') AS INTEGER)'; }\n    $dayOfMonth(p0) { return 'CAST(strftime(\\'%d\\', ' + this.escape(p0) + ') AS INTEGER)'; }\n    $month(p0) { return 'CAST(strftime(\\'%m\\', ' + this.escape(p0) + ') AS INTEGER)'; }\n    $year(p0) { return 'CAST(strftime(\\'%Y\\', ' + this.escape(p0) + ') AS INTEGER)'; }\n    $hour(p0) { return 'CAST(strftime(\\'%H\\', ' + this.escape(p0) + ') AS INTEGER)'; }\n    $minute(p0) { return 'CAST(strftime(\\'%M\\', ' + this.escape(p0) + ') AS INTEGER)'; }\n    $second(p0) { return 'CAST(strftime(\\'%S\\', ' + this.escape(p0) + ') AS INTEGER)'; }\n    $date(p0) { return 'date(' + this.escape(p0) + ')'; }\n}\n\nSqliteFormatter.NAME_FORMAT = '`$1`';\n\nconst REGEXP_SINGLE_QUOTE=/\\\\'/g, SINGLE_QUOTE_ESCAPE ='\\'\\'',\n    REGEXP_DOUBLE_QUOTE=/\\\\\"/g, DOUBLE_QUOTE_ESCAPE = '\"',\n    REGEXP_SLASH=/\\\\\\\\/g, SLASH_ESCAPE = '\\\\';\n\n/**\n * Creates an instance of SqliteAdapter object that represents a SQLite database connection.\n * @param {*} options An object that represents the properties of the underlying database connection.\n * @returns {*}\n */\nexport function createInstance(options) {\n    return new SqliteAdapter(options);\n}\n"]}